
import { Con, Row, Col } from 'bee-layout';
import { Panel } from 'bee-panel';
import Button from 'bee-button';
import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import D3Graph from '../src';


const CARET = <i className="uf uf-arrow-down"></i>;

const CARETUP = <i className="uf uf-arrow-up"></i>;


var Demo1 = require("./demolist/Demo1");var Demo4 = require("./demolist/Demo4");var Demo5 = require("./demolist/Demo5");var Demo6 = require("./demolist/Demo6");var Demo7 = require("./demolist/Demo7");var Demo8 = require("./demolist/Demo8");var DemoArray = [{"example":<Demo1 />,"title":" d3环形饼状图","code":"/**\n*\n* @title d3环形饼状图\n* @description\n* label: 标签名称\n* unit: 单位\n* title: 标题\n* circelSpan:  饼状环的宽度\n* labelLineLength1: 第一段引出线的长度\n* labelLineLength2: 第二段引出线的长度\n* value: 数据\n*\n*/\n\nimport React, { Component } from 'react';\nimport D3Graph from 'tinper-bee';\n\nclass Demo1 extends Component {\n\trender () {\n\t\treturn (\n\t\t\t<div style={{width: 500,height: 500}}>\n\t\t\t\t<D3Graph\n\t\t\t\t\tlabel={['健康', '异常', '未知']}\n\t\t\t\t\tunit='个'\n\t\t\t\t\ttitle='应用健康状况比例图'\n\t\t\t\t\talpha={0.5}\n\t\t\t\t\tcircleSpan={[25,15,10]}\n\t\t\t\t\tlabelLineLength1={25}\n\t\t\t\t\tlabelLineLength2={100}\n\t\t\t\t\tvalue={[10, 10, 10]}\n\t\t\t\t>\n\n\t\t\t\t</D3Graph>\n\t\t\t</div>\n\n\t\t)\n\t}\n}\n\n","desc":""},{"example":<Demo4 />,"title":" d3环形饼状图","code":"/**\n*\n* @title d3环形饼状图\n* @description\n* label: 标签名称\n* unit: 单位\n* title: 标题\n* circelSpan:  饼状环的宽度\n* labelLineLength1: 第一段引出线的长度\n* labelLineLength2: 第二段引出线的长度\n* value: 数据\n*\n*/\n\nimport React, { Component } from 'react';\nimport D3Graph from 'tinper-bee';\n\nclass Demo4 extends Component {\n\tcomponentDidMount () {\n\t\tthis.InitCanvas();\n\t}\n\n\tInitCanvas = () => {\n        let root = {\n\t\t        \"honourInfo\": [\n\t\t            {\n\t\t                \"userName\": \"郑龙强\",\n\t\t                \"avatar\": \"http://staticoss.upesn.com/5417/3125390/201704/7/149156392540abee656cab633426e40098a4083cfb.jpg\"\n\t\t            },\n\t\t            {\n\t\t                \"amount\": 2,\n\t\t                \"avatar\": \"http://staticoss.upesn.com/5417/2902446/201704/5/14914020994f450245f3229a29f635243a0a2b6ac2.jpg\",\n\t\t                \"memberId\": 5423,\n\t\t                \"userName\": \"郭永峰\"\n\t\t            },\n\t\t            {\n\t\t                \"amount\": 2,\n\t\t                \"avatar\": \"http://staticoss.upesn.com/5417/2902446/201704/5/14914020994f450245f3229a29f635243a0a2b6ac2.jpg\",\n\t\t                \"memberId\": 5423,\n\t\t                \"userName\": \"郭永峰1\"\n\t\t            }\n\t\t        ]\n\t\t}\n      \tvar maxWidth = 600;\n      \tvar width, height, img_h, img_w, radius, text_dx, text_dy;\n\n\t    try {\n\t          if (/iPhone|mac|iPod|iPad/i.test(navigator.userAgent)) {\n\t              width = maxWidth - 20;\n\t              height = 400;\n\t              img_w = maxWidth / 3;\n\t              img_h = maxWidth / 3;\n\t              radius = 70;\n\t              text_dx = -50;\n\t              text_dy = -20;\n\t              var svg = d3\n\t                  .select(\"#app\")\n\t                  .append(\"svg\")\n\t                  .attr(\"width\", width)\n\t                  .attr(\"height\", height);\n\n\t              var len = root.honourInfo.length;\n\t              root.edges = [];\n\n\t              for(var i=0;i<len;i++) {\n\t                  root.edges.push({ \"source\": 0 , \"target\": i });\n\t              }\n\t              //D3力导向布局\n\t              var force = d3.layout.force()\n\t                  .nodes(root.honourInfo)\n\t                  .links(root.edges)\n\t                  .size([width,height])\n\t                  .linkDistance(350)\n\t                  .charge(-2000)\n\t                  .start();\n\t          } else {\n\t              width = maxWidth - 20;\n\t              height = 400;\n\t              img_w = maxWidth / 4;\n\t              img_h = maxWidth / 4;\n\t              radius = 30;\n\t              text_dx = -35;\n\t              text_dy = 10;\n\t              var svg = d3\n\t                  .select(\"#app\")\n\t                  .append(\"svg\")\n\t                  .attr(\"width\", width)\n\t                  .attr(\"height\", height);\n\n\t              var len = root.honourInfo.length;\n\t              root.edges = [];\n\n\t              for(var i=0;i<len;i++) {\n\t                  root.edges.push({ \"source\": 0 , \"target\": i });\n\t              }\n\t              //D3力导向布局\n\t              var force = d3.layout.force()\n\t                  .nodes(root.honourInfo)\n\t                  .links(root.edges)\n\t                  .size([width,height])\n\t                  .linkDistance(150)\n\t                  .charge(-2000)\n\t                  .start();\n\t          }\n\t    } catch (e) {\n\t    }\n        //边\n        var edges_line = svg.selectAll(\"line\")\n                            .data(root.edges)\n                            .enter()\n                            .append(\"line\")\n                            .style(\"stroke\",\"#e0e0e0\")\n                            .style(\"stroke-width\",3);\n\n        //边上的文字（人物之间的关系）\n        var edges_text = svg.selectAll(\".linetext\")\n                            .data(root.edges)\n                            .enter()\n                            .append(\"text\")\n                            .attr(\"class\",\"linetext\")\n                            .text(function(d){\n                                return d.relation;\n                            });\n\n\n        // 圆形图片节点（人物头像）\n        var nodes_img = svg.selectAll(\"image\")\n                            .data(root.honourInfo)\n                            .enter()\n                            .append(\"circle\")\n                            .attr(\"class\", \"circleImg\")\n                            .attr(\"r\", radius)\n                            .attr(\"fill\", function(d, i){\n\n                                //创建圆形图片\n                                var defs = svg.append(\"defs\").attr(\"id\", \"imgdefs\")\n\n                                var catpattern = defs.append(\"pattern\")\n                                                        .attr(\"id\", \"catpattern\" + i)\n                                                        .attr(\"height\", 1)\n                                                        .attr(\"width\", 1)\n\n                                catpattern.append(\"image\")\n                                        .attr(\"x\", - (img_w / 2 - radius))\n                                        .attr(\"y\", - (img_h / 2 - radius))\n                                        .attr(\"width\", img_w)\n                                        .attr(\"height\", img_h)\n                                        .attr(\"xlink:href\", d.avatar)\n\n                                return \"url(#catpattern\" + i + \")\";\n\n                            })\n                            // .on(\"mouseover\",function(d,i){\n                            //     //显示连接线上的文字\n                            //     edges_text.style(\"fill-opacity\",function(edge){\n                            //         if( edge.source === d || edge.target === d ){\n                            //             return 1.0;\n                            //         }\n                            //     });\n                            // })\n                            // .on(\"mouseout\",function(d,i){\n                            //     //隐去连接线上的文字\n                            //     edges_text.style(\"fill-opacity\",function(edge){\n                            //         if( edge.source === d || edge.target === d ){\n                            //             return 0.0;\n                            //         }\n                            //     });\n                            // })\n                            .call(force.drag);\n\n\n\n        var nodes_text = svg.selectAll(\".nodetext\")\n                            .data(root.honourInfo)\n                            .enter()\n                            .append(\"text\")\n                            .attr(\"class\",\"nodetext\")\n                            .attr(\"dx\",text_dx)\n                            .attr(\"dy\",text_dy)\n                            .text(function(d){\n                              if(d.amount) {\n                                return d.userName + d.amount + \"项\";\n                              } else {\n                                return \"\";\n                              }\n                            });\n\n\n        force.on(\"tick\", function(){\n\n            //限制结点的边界\n            root.honourInfo.forEach(function(d,i){\n                d.x = d.x - img_w/2 < 0     ? img_w/2 : d.x ;\n                d.x = d.x + img_w/2 > width ? width - img_w/2 : d.x ;\n                d.y = d.y - img_h/2 < 0      ? img_h/2 : d.y ;\n                d.y = d.y + img_h/2 + text_dy > height ? height - img_h/2 - text_dy : d.y ;\n            });\n\n            //更新连接线的位置\n             edges_line.attr(\"x1\",function(d){ return d.source.x; });\n             edges_line.attr(\"y1\",function(d){ return d.source.y; });\n             edges_line.attr(\"x2\",function(d){ return d.target.x; });\n             edges_line.attr(\"y2\",function(d){ return d.target.y; });\n\n             //更新连接线上文字的位置\n             edges_text.attr(\"x\",function(d){ return (d.source.x + d.target.x) / 2 ; });\n             edges_text.attr(\"y\",function(d){ return (d.source.y + d.target.y) / 2 ; });\n\n\n             //更新结点图片和文字\n             nodes_img.attr(\"cx\",function(d){ return d.x });\n             nodes_img.attr(\"cy\",function(d){ return d.y });\n\n             nodes_text.attr(\"x\",function(d){ return d.x });\n             nodes_text.attr(\"y\",function(d){ return d.y + img_w/2; });\n        });\n       \n\n  \t}\n\trender () {\n\t\treturn (\n\t\t\t<div id=\"app\"></div>\n\n\t\t)\n\t}\n}\n\n","desc":""},{"example":<Demo5 />,"title":" 液体灌装仪","code":"/**\n*\n* @title 液体灌装仪\n*\n*/\n\nimport React, { Component } from 'react';\nimport D3Graph from 'tinper-bee';\n\nclass Demo5 extends Component {\n\tcomponentDidMount () {\n\t\tvar gauge1 = this.loadLiquidFillGauge(\"fillgauge1\", 55);\n\t    var config1 = this.liquidFillGaugeDefaultSettings();\n\t    config1.circleColor = \"#FF7777\";\n\t    config1.textColor = \"#FF4444\";\n\t    config1.waveTextColor = \"#FFAAAA\";\n\t    config1.waveColor = \"#FFDDDD\";\n\t    config1.circleThickness = 0.2;\n\t    config1.textVertPosition = 0.2;\n\t    config1.waveAnimateTime = 1000;\n\t    var gauge2= this.loadLiquidFillGauge(\"fillgauge2\", 28, config1);\n\t    var config2 = this.liquidFillGaugeDefaultSettings();\n\t    config2.circleColor = \"#D4AB6A\";\n\t    config2.textColor = \"#553300\";\n\t    config2.waveTextColor = \"#805615\";\n\t    config2.waveColor = \"#AA7D39\";\n\t    config2.circleThickness = 0.1;\n\t    config2.circleFillGap = 0.2;\n\t    config2.textVertPosition = 0.8;\n\t    config2.waveAnimateTime = 2000;\n\t    config2.waveHeight = 0.3;\n\t    config2.waveCount = 1;\n\t    var gauge3 = this.loadLiquidFillGauge(\"fillgauge3\", 60.1, config2);\n\t    var config3 = this.liquidFillGaugeDefaultSettings();\n\t    config3.textVertPosition = 0.8;\n\t    config3.waveAnimateTime = 5000;\n\t    config3.waveHeight = 0.15;\n\t    config3.waveAnimate = false;\n\t    config3.waveOffset = 0.25;\n\t    config3.valueCountUp = false;\n\t    config3.displayPercent = false;\n\t    var gauge4 = this.loadLiquidFillGauge(\"fillgauge4\", 50, config3);\n\t    var config4 = this.liquidFillGaugeDefaultSettings();\n\t    config4.circleThickness = 0.15;\n\t    config4.circleColor = \"#808015\";\n\t    config4.textColor = \"#555500\";\n\t    config4.waveTextColor = \"#FFFFAA\";\n\t    config4.waveColor = \"#AAAA39\";\n\t    config4.textVertPosition = 0.8;\n\t    config4.waveAnimateTime = 1000;\n\t    config4.waveHeight = 0.05;\n\t    config4.waveAnimate = true;\n\t    config4.waveRise = false;\n\t    config4.waveHeightScaling = false;\n\t    config4.waveOffset = 0.25;\n\t    config4.textSize = 0.75;\n\t    config4.waveCount = 3;\n\t    var gauge5 = this.loadLiquidFillGauge(\"fillgauge5\", 60.44, config4);\n\t    var config5 = this.liquidFillGaugeDefaultSettings();\n\t    config5.circleThickness = 0.4;\n\t    config5.circleColor = \"#6DA398\";\n\t    config5.textColor = \"#0E5144\";\n\t    config5.waveTextColor = \"#6DA398\";\n\t    config5.waveColor = \"#246D5F\";\n\t    config5.textVertPosition = 0.52;\n\t    config5.waveAnimateTime = 5000;\n\t    config5.waveHeight = 0;\n\t    config5.waveAnimate = false;\n\t    config5.waveCount = 2;\n\t    config5.waveOffset = 0.25;\n\t    config5.textSize = 1.2;\n\t    config5.minValue = 30;\n\t    config5.maxValue = 150\n\t    config5.displayPercent = false;\n\t    var gauge6 = this.loadLiquidFillGauge(\"fillgauge6\", 120, config5);\n\n    \n\t}\n\n\tNewValue = () => {\n        if(Math.random() > .5){\n            return Math.round(Math.random()*100);\n        } else {\n            return (Math.random()*100).toFixed(1);\n        }\n    }\n\n    liquidFillGaugeDefaultSettings = () =>{\n\t    return {\n\t        minValue: 0, // The gauge minimum value.\n\t        maxValue: 100, // The gauge maximum value.\n\t        circleThickness: 0.05, // The outer circle thickness as a percentage of it's radius.\n\t        circleFillGap: 0.05, // The size of the gap between the outer circle and wave circle as a percentage of the outer circles radius.\n\t        circleColor: \"#178BCA\", // The color of the outer circle.\n\t        waveHeight: 0.05, // The wave height as a percentage of the radius of the wave circle.\n\t        waveCount: 1, // The number of full waves per width of the wave circle.\n\t        waveRiseTime: 1000, // The amount of time in milliseconds for the wave to rise from 0 to it's final height.\n\t        waveAnimateTime: 18000, // The amount of time in milliseconds for a full wave to enter the wave circle.\n\t        waveRise: true, // Control if the wave should rise from 0 to it's full height, or start at it's full height.\n\t        waveHeightScaling: true, // Controls wave size scaling at low and high fill percentages. When true, wave height reaches it's maximum at 50% fill, and minimum at 0% and 100% fill. This helps to prevent the wave from making the wave circle from appear totally full or empty when near it's minimum or maximum fill.\n\t        waveAnimate: true, // Controls if the wave scrolls or is static.\n\t        waveColor: \"#178BCA\", // The color of the fill wave.\n\t        waveOffset: 0, // The amount to initially offset the wave. 0 = no offset. 1 = offset of one full wave.\n\t        textVertPosition: .5, // The height at which to display the percentage text withing the wave circle. 0 = bottom, 1 = top.\n\t        textSize: 1, // The relative height of the text to display in the wave circle. 1 = 50%\n\t        valueCountUp: true, // If true, the displayed value counts up from 0 to it's final value upon loading. If false, the final value is displayed.\n\t        displayPercent: true, // If true, a % symbol is displayed after the value.\n\t        textColor: \"#045681\", // The color of the value text when the wave does not overlap it.\n\t        waveTextColor: \"#A4DBf8\" // The color of the value text when the wave overlaps it.\n\t    };\n\t}\n\n\tloadLiquidFillGauge = (elementId, value, config) => {\n\t    if(config == null) config = this.liquidFillGaugeDefaultSettings();\n\n\t    var gauge = d3.select(\"#\" + elementId);\n\t    var radius = Math.min(parseInt(gauge.style(\"width\")), parseInt(gauge.style(\"height\")))/2;\n\t    var locationX = parseInt(gauge.style(\"width\"))/2 - radius;\n\t    var locationY = parseInt(gauge.style(\"height\"))/2 - radius;\n\t    var fillPercent = Math.max(config.minValue, Math.min(config.maxValue, value))/config.maxValue;\n\n\t    var waveHeightScale;\n\t    if(config.waveHeightScaling){\n\t        waveHeightScale = d3.scale.linear()\n\t            .range([0,config.waveHeight,0])\n\t            .domain([0,50,100]);\n\t    } else {\n\t        waveHeightScale = d3.scale.linear()\n\t            .range([config.waveHeight,config.waveHeight])\n\t            .domain([0,100]);\n\t    }\n\n\t    var textPixels = (config.textSize*radius/2);\n\t    var textFinalValue = parseFloat(value).toFixed(2);\n\t    var textStartValue = config.valueCountUp?config.minValue:textFinalValue;\n\t    var percentText = config.displayPercent?\"%\":\"\";\n\t    var circleThickness = config.circleThickness * radius;\n\t    var circleFillGap = config.circleFillGap * radius;\n\t    var fillCircleMargin = circleThickness + circleFillGap;\n\t    var fillCircleRadius = radius - fillCircleMargin;\n\t    var waveHeight = fillCircleRadius*waveHeightScale(fillPercent*100);\n\n\t    var waveLength = fillCircleRadius*2/config.waveCount;\n\t    var waveClipCount = 1+config.waveCount;\n\t    var waveClipWidth = waveLength*waveClipCount;\n\n\t    // Rounding functions so that the correct number of decimal places is always displayed as the value counts up.\n\t    var textRounder = function(value){ return Math.round(value); };\n\t    if(parseFloat(textFinalValue) != parseFloat(textRounder(textFinalValue))){\n\t        textRounder = function(value){ return parseFloat(value).toFixed(1); };\n\t    }\n\t    if(parseFloat(textFinalValue) != parseFloat(textRounder(textFinalValue))){\n\t        textRounder = function(value){ return parseFloat(value).toFixed(2); };\n\t    }\n\n\t    // Data for building the clip wave area.\n\t    var data = [];\n\t    for(var i = 0; i <= 40*waveClipCount; i++){\n\t        data.push({x: i/(40*waveClipCount), y: (i/(40))});\n\t    }\n\n\t    // Scales for drawing the outer circle.\n\t    var gaugeCircleX = d3.scale.linear().range([0,2*Math.PI]).domain([0,1]);\n\t    var gaugeCircleY = d3.scale.linear().range([0,radius]).domain([0,radius]);\n\n\t    // Scales for controlling the size of the clipping path.\n\t    var waveScaleX = d3.scale.linear().range([0,waveClipWidth]).domain([0,1]);\n\t    var waveScaleY = d3.scale.linear().range([0,waveHeight]).domain([0,1]);\n\n\t    // Scales for controlling the position of the clipping path.\n\t    var waveRiseScale = d3.scale.linear()\n\t        // The clipping area size is the height of the fill circle + the wave height, so we position the clip wave\n\t        // such that the it will overlap the fill circle at all when at 0%, and will totally cover the fill\n\t        // circle at 100%.\n\t        .range([(fillCircleMargin+fillCircleRadius*2+waveHeight),(fillCircleMargin-waveHeight)])\n\t        .domain([0,1]);\n\t    var waveAnimateScale = d3.scale.linear()\n\t        .range([0, waveClipWidth-fillCircleRadius*2]) // Push the clip area one full wave then snap back.\n\t        .domain([0,1]);\n\n\t    // Scale for controlling the position of the text within the gauge.\n\t    var textRiseScaleY = d3.scale.linear()\n\t        .range([fillCircleMargin+fillCircleRadius*2,(fillCircleMargin+textPixels*0.7)])\n\t        .domain([0,1]);\n\n\t    // Center the gauge within the parent SVG.\n\t    var gaugeGroup = gauge.append(\"g\")\n\t        .attr('transform','translate('+locationX+','+locationY+')');\n\n\t    // Draw the outer circle.\n\t    var gaugeCircleArc = d3.svg.arc()\n\t        .startAngle(gaugeCircleX(0))\n\t        .endAngle(gaugeCircleX(1))\n\t        .outerRadius(gaugeCircleY(radius))\n\t        .innerRadius(gaugeCircleY(radius-circleThickness));\n\t    gaugeGroup.append(\"path\")\n\t        .attr(\"d\", gaugeCircleArc)\n\t        .style(\"fill\", config.circleColor)\n\t        .attr('transform','translate('+radius+','+radius+')');\n\n\t    // Text where the wave does not overlap.\n\t    var text1 = gaugeGroup.append(\"text\")\n\t        .text(textRounder(textStartValue) + percentText)\n\t        .attr(\"class\", \"liquidFillGaugeText\")\n\t        .attr(\"text-anchor\", \"middle\")\n\t        .attr(\"font-size\", textPixels + \"px\")\n\t        .style(\"fill\", config.textColor)\n\t        .attr('transform','translate('+radius+','+textRiseScaleY(config.textVertPosition)+')');\n\n\t    // The clipping wave area.\n\t    var clipArea = d3.svg.area()\n\t        .x(function(d) { return waveScaleX(d.x); } )\n\t        .y0(function(d) { return waveScaleY(Math.sin(Math.PI*2*config.waveOffset*-1 + Math.PI*2*(1-config.waveCount) + d.y*2*Math.PI));} )\n\t        .y1(function(d) { return (fillCircleRadius*2 + waveHeight); } );\n\t    var waveGroup = gaugeGroup.append(\"defs\")\n\t        .append(\"clipPath\")\n\t        .attr(\"id\", \"clipWave\" + elementId);\n\t    var wave = waveGroup.append(\"path\")\n\t        .datum(data)\n\t        .attr(\"d\", clipArea)\n\t        .attr(\"T\", 0);\n\n\t    // The inner circle with the clipping wave attached.\n\t    var fillCircleGroup = gaugeGroup.append(\"g\")\n\t        .attr(\"clip-path\", \"url(#clipWave\" + elementId + \")\");\n\t    fillCircleGroup.append(\"circle\")\n\t        .attr(\"cx\", radius)\n\t        .attr(\"cy\", radius)\n\t        .attr(\"r\", fillCircleRadius)\n\t        .style(\"fill\", config.waveColor);\n\n\t    // Text where the wave does overlap.\n\t    var text2 = fillCircleGroup.append(\"text\")\n\t        .text(textRounder(textStartValue) + percentText)\n\t        .attr(\"class\", \"liquidFillGaugeText\")\n\t        .attr(\"text-anchor\", \"middle\")\n\t        .attr(\"font-size\", textPixels + \"px\")\n\t        .style(\"fill\", config.waveTextColor)\n\t        .attr('transform','translate('+radius+','+textRiseScaleY(config.textVertPosition)+')');\n\n\t    // Make the value count up.\n\t    if(config.valueCountUp){\n\t        var textTween = function(){\n\t            var i = d3.interpolate(this.textContent, textFinalValue);\n\t            return function(t) { this.textContent = textRounder(i(t)) + percentText; }\n\t        };\n\t        text1.transition()\n\t            .duration(config.waveRiseTime)\n\t            .tween(\"text\", textTween);\n\t        text2.transition()\n\t            .duration(config.waveRiseTime)\n\t            .tween(\"text\", textTween);\n\t    }\n\n\t    // Make the wave rise. wave and waveGroup are separate so that horizontal and vertical movement can be controlled independently.\n\t    var waveGroupXPosition = fillCircleMargin+fillCircleRadius*2-waveClipWidth;\n\t    if(config.waveRise){\n\t        waveGroup.attr('transform','translate('+waveGroupXPosition+','+waveRiseScale(0)+')')\n\t            .transition()\n\t            .duration(config.waveRiseTime)\n\t            .attr('transform','translate('+waveGroupXPosition+','+waveRiseScale(fillPercent)+')')\n\t            .each(\"start\", function(){ wave.attr('transform','translate(1,0)'); }); // This transform is necessary to get the clip wave positioned correctly when waveRise=true and waveAnimate=false. The wave will not position correctly without this, but it's not clear why this is actually necessary.\n\t    } else {\n\t        waveGroup.attr('transform','translate('+waveGroupXPosition+','+waveRiseScale(fillPercent)+')');\n\t    }\n\n\t    if(config.waveAnimate) animateWave();\n\n\t    function animateWave() {\n\t        wave.attr('transform','translate('+waveAnimateScale(wave.attr('T'))+',0)');\n\t        wave.transition()\n\t            .duration(config.waveAnimateTime * (1-wave.attr('T')))\n\t            .ease('linear')\n\t            .attr('transform','translate('+waveAnimateScale(1)+',0)')\n\t            .attr('T', 1)\n\t            .each('end', function(){\n\t                wave.attr('T', 0);\n\t                animateWave(config.waveAnimateTime);\n\t            });\n\t    }\n\n\t    function GaugeUpdater(){\n\t        this.update = function(value){\n\t            var newFinalValue = parseFloat(value).toFixed(2);\n\t            var textRounderUpdater = function(value){ return Math.round(value); };\n\t            if(parseFloat(newFinalValue) != parseFloat(textRounderUpdater(newFinalValue))){\n\t                textRounderUpdater = function(value){ return parseFloat(value).toFixed(1); };\n\t            }\n\t            if(parseFloat(newFinalValue) != parseFloat(textRounderUpdater(newFinalValue))){\n\t                textRounderUpdater = function(value){ return parseFloat(value).toFixed(2); };\n\t            }\n\n\t            var textTween = function(){\n\t                var i = d3.interpolate(this.textContent, parseFloat(value).toFixed(2));\n\t                return function(t) { this.textContent = textRounderUpdater(i(t)) + percentText; }\n\t            };\n\n\t            text1.transition()\n\t                .duration(config.waveRiseTime)\n\t                .tween(\"text\", textTween);\n\t            text2.transition()\n\t                .duration(config.waveRiseTime)\n\t                .tween(\"text\", textTween);\n\n\t            var fillPercent = Math.max(config.minValue, Math.min(config.maxValue, value))/config.maxValue;\n\t            var waveHeight = fillCircleRadius*waveHeightScale(fillPercent*100);\n\t            var waveRiseScale = d3.scale.linear()\n\t                // The clipping area size is the height of the fill circle + the wave height, so we position the clip wave\n\t                // such that the it will overlap the fill circle at all when at 0%, and will totally cover the fill\n\t                // circle at 100%.\n\t                .range([(fillCircleMargin+fillCircleRadius*2+waveHeight),(fillCircleMargin-waveHeight)])\n\t                .domain([0,1]);\n\t            var newHeight = waveRiseScale(fillPercent);\n\t            var waveScaleX = d3.scale.linear().range([0,waveClipWidth]).domain([0,1]);\n\t            var waveScaleY = d3.scale.linear().range([0,waveHeight]).domain([0,1]);\n\t            var newClipArea;\n\t            if(config.waveHeightScaling){\n\t                newClipArea = d3.svg.area()\n\t                    .x(function(d) { return waveScaleX(d.x); } )\n\t                    .y0(function(d) { return waveScaleY(Math.sin(Math.PI*2*config.waveOffset*-1 + Math.PI*2*(1-config.waveCount) + d.y*2*Math.PI));} )\n\t                    .y1(function(d) { return (fillCircleRadius*2 + waveHeight); } );\n\t            } else {\n\t                newClipArea = clipArea;\n\t            }\n\n\t            var newWavePosition = config.waveAnimate?waveAnimateScale(1):0;\n\t            wave.transition()\n\t                .duration(0)\n\t                .transition()\n\t                .duration(config.waveAnimate?(config.waveAnimateTime * (1-wave.attr('T'))):(config.waveRiseTime))\n\t                .ease('linear')\n\t                .attr('d', newClipArea)\n\t                .attr('transform','translate('+newWavePosition+',0)')\n\t                .attr('T','1')\n\t                .each(\"end\", function(){\n\t                    if(config.waveAnimate){\n\t                        wave.attr('transform','translate('+waveAnimateScale(0)+',0)');\n\t                        animateWave(config.waveAnimateTime);\n\t                    }\n\t                });\n\t            waveGroup.transition()\n\t                .duration(config.waveRiseTime)\n\t                .attr('transform','translate('+waveGroupXPosition+','+newHeight+')')\n\t        }\n\t    }\n\n\t    return new GaugeUpdater();\n\t}\n\n\trender () {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t<svg id=\"fillgauge1\" width=\"97%\" height=\"250\"></svg>\n\t\t\t\t<svg id=\"fillgauge2\" width=\"19%\" height=\"200\"></svg>\n\t\t\t\t<svg id=\"fillgauge3\" width=\"19%\" height=\"200\" ></svg>\n\t\t\t\t<svg id=\"fillgauge4\" width=\"19%\" height=\"200\"></svg>\n\t\t\t\t<svg id=\"fillgauge5\" width=\"19%\" height=\"200\"></svg>\n\t\t\t\t<svg id=\"fillgauge6\" width=\"19%\" height=\"200\"></svg>\n\t\t\t</div>\n\t\t)\n\t}\n}\n\n","desc":""},{"example":<Demo6 />,"title":" 线性图","code":"/**\n*\n* @title 线性图\n*\n*/\n\nimport React, { Component } from 'react';\nimport D3Graph from 'tinper-bee';\n\n\nclass Demo6 extends Component {\n    componentDidMount () {\n        var margin = {top: 40, right: 40, bottom: 40, left: 40},\n        width = 960 - margin.left - margin.right,\n        height = 500 - margin.top - margin.bottom;\n\n    var x = d3.scale.linear()\n        .domain([0, 1])\n        .range([0, width]);\n\n    var y = d3.scale.linear()\n        .domain([0, 1])\n        .range([height, 0]);\n\n    var z = d3.scale.linear()\n        .domain([2 / 3, 1]) // D3 3.x tension is buggy!\n        .range([\"brown\", \"steelblue\"]);\n\n    var xAxis = d3.svg.axis()\n        .scale(x)\n        .orient(\"bottom\");\n\n    var yAxis = d3.svg.axis()\n        .scale(y)\n        .orient(\"left\");\n\n    var line = d3.svg.line()\n        .interpolate(\"cardinal\")\n        .x(function(d) { return x(d.x); })\n        .y(function(d) { return y(d.y); });\n\n    var svg = d3.select(\"#tsv\").append(\"svg\")\n        .attr(\"width\", width + margin.left + margin.right)\n        .attr(\"height\", height + margin.top + margin.bottom)\n      .append(\"g\")\n        .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n    d3.tsv(\"data.tsv\", type, function(error, data) {\n      if (error) throw error;\n\n      svg.append(\"g\")\n          .attr(\"class\", \"axis axis--x\")\n          .attr(\"transform\", \"translate(0,\" + height + \")\")\n          .call(xAxis);\n\n      svg.append(\"g\")\n          .attr(\"class\", \"axis axis--y\")\n          .call(yAxis);\n\n      svg.selectAll(\".line\")\n          .data(z.ticks(6))\n        .enter().append(\"path\")\n          .attr(\"class\", \"line\")\n          .attr(\"d\", function(d) { return line.tension(d)(data); })\n          .style(\"stroke\", z);\n\n      svg.selectAll(\".dot\")\n          .data(data)\n        .enter().append(\"circle\")\n          .attr(\"class\", \"dot\")\n          .attr(\"cx\", function(d) { return x(d.x); })\n          .attr(\"cy\", function(d) { return y(d.y); })\n          .attr(\"r\", 3.5);\n    });\n\n    function type(d) {\n      d.x = +d.x;\n      d.y = +d.y;\n      return d;\n    }\n    }\n    render () {\n        return (\n            <div id=\"tsv\"></div>\n        )\n    }\n}\n\n","desc":""},{"example":<Demo7 />,"title":" 冒泡点","code":"\n\n\n/**\n*\n* @title 冒泡点\n*\n*/\n\nimport React, { Component } from 'react';\nimport D3Graph from 'tinper-bee';\n\n\nclass Demo6 extends Component {\n    componentDidMount () {\n        var width = 960,\n            height = 500;\n\n        var nodes = [];\n\n        var svg = d3.select(\"#dot\").append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n\n        var force = d3.layout.force()\n            .charge(-20)\n            .size([width, height])\n            .nodes(nodes)\n            .on(\"tick\", tick)\n            .start();\n\n        function tick() {\n          svg.selectAll(\"circle\")\n              .attr(\"cx\", function(d) { return d.x; })\n              .attr(\"cy\", function(d) { return d.y; });\n        }\n\n        var interval = setInterval(function() {\n          var d = {\n            x: width / 2 + 2 * Math.random() - 1,\n            y: height / 2 + 2 * Math.random() - 1\n          };\n\n          svg.append(\"circle\")\n              .data([d])\n              .attr(\"r\", 1e-6)\n            .transition()\n              .ease(Math.sqrt)\n              .attr(\"r\", 4.5);\n\n          if (nodes.push(d) > 300) clearInterval(interval);\n          force.start();\n        }, 30);\n    }\n    render () {\n        return (\n            <div id=\"dot\"></div>\n        )\n    }\n}\n\n","desc":""},{"example":<Demo8 />,"title":" 动态时间线","code":"/**\n*\n* @title 动态时间线\n*\n*/\n\nimport React, { Component } from 'react';\nimport D3Graph from 'tinper-bee';\n\nclass Demo8 extends Component {\n\tcomponentDidMount () {\n\t\tvar duration = 2500,\n\t\t    delay = 500;\n\n\t\tvar width = 960,\n\t\t    height = 500;\n\n\t\tvar x = d3.time.scale()\n\t\t    .domain([new Date(2010, 0, 2), new Date(2010, 1, 1)])\n\t\t    .range([0, width]);\n\n\t\tvar xAxis = d3.svg.axis()\n\t\t    .scale(x)\n\t\t    .orient(\"bottom\")\n\t\t    .tickSize(6, 0)\n\t\t    .tickFormat(d3.time.format(\"%m/%d\"));\n\n\t\tvar svg = d3.select(\"#date\").append(\"svg\")\n\t\t    .attr(\"width\", width)\n\t\t    .attr(\"height\", height);\n\n\t\tvar g = svg.append(\"g\")\n\t\t    .attr(\"class\", \"axis\")\n\t\t    .attr(\"transform\", \"translate(0,\" + height / 2 + \")\")\n\t\t    .call(xAxis);\n\n\t\tsetInterval(update, duration + delay);\n\n\t\tfunction update() {\n\t\t  x.domain([new Date(2010, 0, 2), new Date(2010, 0, Math.floor(Math.random() * 21) + 10)]);\n\n\t\t  g.transition()\n\t\t      .duration(duration)\n\t\t      .call(xAxis);\n\t\t}\n\t}\n\trender () {\n\t\treturn (\n\t\t\t<div id=\"date\">\n\t\t\t\t\n\t\t\t</div>\n\t\t)\n\t}\n}\n\n","desc":""}]


class Demo extends Component {
    constructor(props){
        super(props);
        this.state = {
            open: false
        }
        this.handleClick = this.handleClick.bind(this);
    }
    handleClick() {
        this.setState({ open: !this.state.open })
    }

    render () {
        const { title, example, code, desc  } = this.props;
        let caret = this.state.open ? CARETUP : CARET;
        let text = this.state.open ? "隐藏代码" : "查看代码";

        const footer = (
            <Button shape="block" onClick={ this.handleClick }>
                { caret }
                { text }
            </Button>
        );
        return (
            <Col md={12} >
                <h3>{ title }</h3>
                <p>{ desc }</p>
                <Panel collapsible headerContent expanded={ this.state.open } colors='bordered' header={ example } footer={footer} footerStyle = {{padding: 0}}>
                    <pre><code className="hljs javascript">{ code }</code></pre>
                </Panel>
            </Col>
        )
    }
}

class DemoGroup extends Component {
    constructor(props){
        super(props)
    }
    render () {
        return (
                <Row>
                    {DemoArray.map((child,index) => {

                        return (
                            <Demo example= {child.example} title= {child.title} code= {child.code} desc= {child.desc} key= {index}/>
                        )

                    })}
                </Row>
        )
    }
}

ReactDOM.render(<DemoGroup/>, document.getElementById('tinperBeeDemo'));
