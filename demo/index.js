
import { Con, Row, Col } from 'bee-layout';
import { Panel } from 'bee-panel';
import Button from 'bee-button';
import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import D3Graph from '../src';


const CARET = <i className="uf uf-arrow-down"></i>;

const CARETUP = <i className="uf uf-arrow-up"></i>;


var Demo1 = require("./demolist/Demo1");var Demo5 = require("./demolist/Demo5");var Demo6 = require("./demolist/Demo6");var Demo7 = require("./demolist/Demo7");var Demo8 = require("./demolist/Demo8");var DemoArray = [{"example":<Demo1 />,"title":" 这是标题","code":"/**\n*\n* @title 这是标题\n* @description 这是描述\n*\n*/\n\nimport React, { Component } from 'react';\nimport D3Graph from 'tinper-bee';\n\nclass Demo1 extends Component {\n\trender () {\n\t\treturn (\n\t\t\t<div>\n\t\t\t欢迎使用老赵DEMO系统\n\t\t\t</div>\n\t\t)\n\t}\n}\n\n","desc":" 这是描述"},{"example":<Demo5 />,"title":" 这是标题","code":"/**\n*\n* @title 这是标题\n* @description 这是描述\n*\n*/\n\nimport React, { Component } from 'react';\nimport D3Graph from 'tinper-bee';\n\nclass Demo5 extends Component {\n\tcomponentDidMount () {\n\t\tvar gauge1 = this.loadLiquidFillGauge(\"fillgauge1\", 55);\n\t    var config1 = this.liquidFillGaugeDefaultSettings();\n\t    config1.circleColor = \"#FF7777\";\n\t    config1.textColor = \"#FF4444\";\n\t    config1.waveTextColor = \"#FFAAAA\";\n\t    config1.waveColor = \"#FFDDDD\";\n\t    config1.circleThickness = 0.2;\n\t    config1.textVertPosition = 0.2;\n\t    config1.waveAnimateTime = 1000;\n\t    var gauge2= this.loadLiquidFillGauge(\"fillgauge2\", 28, config1);\n\t    var config2 = this.liquidFillGaugeDefaultSettings();\n\t    config2.circleColor = \"#D4AB6A\";\n\t    config2.textColor = \"#553300\";\n\t    config2.waveTextColor = \"#805615\";\n\t    config2.waveColor = \"#AA7D39\";\n\t    config2.circleThickness = 0.1;\n\t    config2.circleFillGap = 0.2;\n\t    config2.textVertPosition = 0.8;\n\t    config2.waveAnimateTime = 2000;\n\t    config2.waveHeight = 0.3;\n\t    config2.waveCount = 1;\n\t    var gauge3 = this.loadLiquidFillGauge(\"fillgauge3\", 60.1, config2);\n\t    var config3 = this.liquidFillGaugeDefaultSettings();\n\t    config3.textVertPosition = 0.8;\n\t    config3.waveAnimateTime = 5000;\n\t    config3.waveHeight = 0.15;\n\t    config3.waveAnimate = false;\n\t    config3.waveOffset = 0.25;\n\t    config3.valueCountUp = false;\n\t    config3.displayPercent = false;\n\t    var gauge4 = this.loadLiquidFillGauge(\"fillgauge4\", 50, config3);\n\t    var config4 = this.liquidFillGaugeDefaultSettings();\n\t    config4.circleThickness = 0.15;\n\t    config4.circleColor = \"#808015\";\n\t    config4.textColor = \"#555500\";\n\t    config4.waveTextColor = \"#FFFFAA\";\n\t    config4.waveColor = \"#AAAA39\";\n\t    config4.textVertPosition = 0.8;\n\t    config4.waveAnimateTime = 1000;\n\t    config4.waveHeight = 0.05;\n\t    config4.waveAnimate = true;\n\t    config4.waveRise = false;\n\t    config4.waveHeightScaling = false;\n\t    config4.waveOffset = 0.25;\n\t    config4.textSize = 0.75;\n\t    config4.waveCount = 3;\n\t    var gauge5 = this.loadLiquidFillGauge(\"fillgauge5\", 60.44, config4);\n\t    var config5 = this.liquidFillGaugeDefaultSettings();\n\t    config5.circleThickness = 0.4;\n\t    config5.circleColor = \"#6DA398\";\n\t    config5.textColor = \"#0E5144\";\n\t    config5.waveTextColor = \"#6DA398\";\n\t    config5.waveColor = \"#246D5F\";\n\t    config5.textVertPosition = 0.52;\n\t    config5.waveAnimateTime = 5000;\n\t    config5.waveHeight = 0;\n\t    config5.waveAnimate = false;\n\t    config5.waveCount = 2;\n\t    config5.waveOffset = 0.25;\n\t    config5.textSize = 1.2;\n\t    config5.minValue = 30;\n\t    config5.maxValue = 150\n\t    config5.displayPercent = false;\n\t    var gauge6 = this.loadLiquidFillGauge(\"fillgauge6\", 120, config5);\n\n    \n\t}\n\n\tNewValue = () => {\n        if(Math.random() > .5){\n            return Math.round(Math.random()*100);\n        } else {\n            return (Math.random()*100).toFixed(1);\n        }\n    }\n\n    liquidFillGaugeDefaultSettings = () =>{\n\t    return {\n\t        minValue: 0, // The gauge minimum value.\n\t        maxValue: 100, // The gauge maximum value.\n\t        circleThickness: 0.05, // The outer circle thickness as a percentage of it's radius.\n\t        circleFillGap: 0.05, // The size of the gap between the outer circle and wave circle as a percentage of the outer circles radius.\n\t        circleColor: \"#178BCA\", // The color of the outer circle.\n\t        waveHeight: 0.05, // The wave height as a percentage of the radius of the wave circle.\n\t        waveCount: 1, // The number of full waves per width of the wave circle.\n\t        waveRiseTime: 1000, // The amount of time in milliseconds for the wave to rise from 0 to it's final height.\n\t        waveAnimateTime: 18000, // The amount of time in milliseconds for a full wave to enter the wave circle.\n\t        waveRise: true, // Control if the wave should rise from 0 to it's full height, or start at it's full height.\n\t        waveHeightScaling: true, // Controls wave size scaling at low and high fill percentages. When true, wave height reaches it's maximum at 50% fill, and minimum at 0% and 100% fill. This helps to prevent the wave from making the wave circle from appear totally full or empty when near it's minimum or maximum fill.\n\t        waveAnimate: true, // Controls if the wave scrolls or is static.\n\t        waveColor: \"#178BCA\", // The color of the fill wave.\n\t        waveOffset: 0, // The amount to initially offset the wave. 0 = no offset. 1 = offset of one full wave.\n\t        textVertPosition: .5, // The height at which to display the percentage text withing the wave circle. 0 = bottom, 1 = top.\n\t        textSize: 1, // The relative height of the text to display in the wave circle. 1 = 50%\n\t        valueCountUp: true, // If true, the displayed value counts up from 0 to it's final value upon loading. If false, the final value is displayed.\n\t        displayPercent: true, // If true, a % symbol is displayed after the value.\n\t        textColor: \"#045681\", // The color of the value text when the wave does not overlap it.\n\t        waveTextColor: \"#A4DBf8\" // The color of the value text when the wave overlaps it.\n\t    };\n\t}\n\n\tloadLiquidFillGauge = (elementId, value, config) => {\n\t    if(config == null) config = this.liquidFillGaugeDefaultSettings();\n\n\t    var gauge = d3.select(\"#\" + elementId);\n\t    var radius = Math.min(parseInt(gauge.style(\"width\")), parseInt(gauge.style(\"height\")))/2;\n\t    var locationX = parseInt(gauge.style(\"width\"))/2 - radius;\n\t    var locationY = parseInt(gauge.style(\"height\"))/2 - radius;\n\t    var fillPercent = Math.max(config.minValue, Math.min(config.maxValue, value))/config.maxValue;\n\n\t    var waveHeightScale;\n\t    if(config.waveHeightScaling){\n\t        waveHeightScale = d3.scale.linear()\n\t            .range([0,config.waveHeight,0])\n\t            .domain([0,50,100]);\n\t    } else {\n\t        waveHeightScale = d3.scale.linear()\n\t            .range([config.waveHeight,config.waveHeight])\n\t            .domain([0,100]);\n\t    }\n\n\t    var textPixels = (config.textSize*radius/2);\n\t    var textFinalValue = parseFloat(value).toFixed(2);\n\t    var textStartValue = config.valueCountUp?config.minValue:textFinalValue;\n\t    var percentText = config.displayPercent?\"%\":\"\";\n\t    var circleThickness = config.circleThickness * radius;\n\t    var circleFillGap = config.circleFillGap * radius;\n\t    var fillCircleMargin = circleThickness + circleFillGap;\n\t    var fillCircleRadius = radius - fillCircleMargin;\n\t    var waveHeight = fillCircleRadius*waveHeightScale(fillPercent*100);\n\n\t    var waveLength = fillCircleRadius*2/config.waveCount;\n\t    var waveClipCount = 1+config.waveCount;\n\t    var waveClipWidth = waveLength*waveClipCount;\n\n\t    // Rounding functions so that the correct number of decimal places is always displayed as the value counts up.\n\t    var textRounder = function(value){ return Math.round(value); };\n\t    if(parseFloat(textFinalValue) != parseFloat(textRounder(textFinalValue))){\n\t        textRounder = function(value){ return parseFloat(value).toFixed(1); };\n\t    }\n\t    if(parseFloat(textFinalValue) != parseFloat(textRounder(textFinalValue))){\n\t        textRounder = function(value){ return parseFloat(value).toFixed(2); };\n\t    }\n\n\t    // Data for building the clip wave area.\n\t    var data = [];\n\t    for(var i = 0; i <= 40*waveClipCount; i++){\n\t        data.push({x: i/(40*waveClipCount), y: (i/(40))});\n\t    }\n\n\t    // Scales for drawing the outer circle.\n\t    var gaugeCircleX = d3.scale.linear().range([0,2*Math.PI]).domain([0,1]);\n\t    var gaugeCircleY = d3.scale.linear().range([0,radius]).domain([0,radius]);\n\n\t    // Scales for controlling the size of the clipping path.\n\t    var waveScaleX = d3.scale.linear().range([0,waveClipWidth]).domain([0,1]);\n\t    var waveScaleY = d3.scale.linear().range([0,waveHeight]).domain([0,1]);\n\n\t    // Scales for controlling the position of the clipping path.\n\t    var waveRiseScale = d3.scale.linear()\n\t        // The clipping area size is the height of the fill circle + the wave height, so we position the clip wave\n\t        // such that the it will overlap the fill circle at all when at 0%, and will totally cover the fill\n\t        // circle at 100%.\n\t        .range([(fillCircleMargin+fillCircleRadius*2+waveHeight),(fillCircleMargin-waveHeight)])\n\t        .domain([0,1]);\n\t    var waveAnimateScale = d3.scale.linear()\n\t        .range([0, waveClipWidth-fillCircleRadius*2]) // Push the clip area one full wave then snap back.\n\t        .domain([0,1]);\n\n\t    // Scale for controlling the position of the text within the gauge.\n\t    var textRiseScaleY = d3.scale.linear()\n\t        .range([fillCircleMargin+fillCircleRadius*2,(fillCircleMargin+textPixels*0.7)])\n\t        .domain([0,1]);\n\n\t    // Center the gauge within the parent SVG.\n\t    var gaugeGroup = gauge.append(\"g\")\n\t        .attr('transform','translate('+locationX+','+locationY+')');\n\n\t    // Draw the outer circle.\n\t    var gaugeCircleArc = d3.svg.arc()\n\t        .startAngle(gaugeCircleX(0))\n\t        .endAngle(gaugeCircleX(1))\n\t        .outerRadius(gaugeCircleY(radius))\n\t        .innerRadius(gaugeCircleY(radius-circleThickness));\n\t    gaugeGroup.append(\"path\")\n\t        .attr(\"d\", gaugeCircleArc)\n\t        .style(\"fill\", config.circleColor)\n\t        .attr('transform','translate('+radius+','+radius+')');\n\n\t    // Text where the wave does not overlap.\n\t    var text1 = gaugeGroup.append(\"text\")\n\t        .text(textRounder(textStartValue) + percentText)\n\t        .attr(\"class\", \"liquidFillGaugeText\")\n\t        .attr(\"text-anchor\", \"middle\")\n\t        .attr(\"font-size\", textPixels + \"px\")\n\t        .style(\"fill\", config.textColor)\n\t        .attr('transform','translate('+radius+','+textRiseScaleY(config.textVertPosition)+')');\n\n\t    // The clipping wave area.\n\t    var clipArea = d3.svg.area()\n\t        .x(function(d) { return waveScaleX(d.x); } )\n\t        .y0(function(d) { return waveScaleY(Math.sin(Math.PI*2*config.waveOffset*-1 + Math.PI*2*(1-config.waveCount) + d.y*2*Math.PI));} )\n\t        .y1(function(d) { return (fillCircleRadius*2 + waveHeight); } );\n\t    var waveGroup = gaugeGroup.append(\"defs\")\n\t        .append(\"clipPath\")\n\t        .attr(\"id\", \"clipWave\" + elementId);\n\t    var wave = waveGroup.append(\"path\")\n\t        .datum(data)\n\t        .attr(\"d\", clipArea)\n\t        .attr(\"T\", 0);\n\n\t    // The inner circle with the clipping wave attached.\n\t    var fillCircleGroup = gaugeGroup.append(\"g\")\n\t        .attr(\"clip-path\", \"url(#clipWave\" + elementId + \")\");\n\t    fillCircleGroup.append(\"circle\")\n\t        .attr(\"cx\", radius)\n\t        .attr(\"cy\", radius)\n\t        .attr(\"r\", fillCircleRadius)\n\t        .style(\"fill\", config.waveColor);\n\n\t    // Text where the wave does overlap.\n\t    var text2 = fillCircleGroup.append(\"text\")\n\t        .text(textRounder(textStartValue) + percentText)\n\t        .attr(\"class\", \"liquidFillGaugeText\")\n\t        .attr(\"text-anchor\", \"middle\")\n\t        .attr(\"font-size\", textPixels + \"px\")\n\t        .style(\"fill\", config.waveTextColor)\n\t        .attr('transform','translate('+radius+','+textRiseScaleY(config.textVertPosition)+')');\n\n\t    // Make the value count up.\n\t    if(config.valueCountUp){\n\t        var textTween = function(){\n\t            var i = d3.interpolate(this.textContent, textFinalValue);\n\t            return function(t) { this.textContent = textRounder(i(t)) + percentText; }\n\t        };\n\t        text1.transition()\n\t            .duration(config.waveRiseTime)\n\t            .tween(\"text\", textTween);\n\t        text2.transition()\n\t            .duration(config.waveRiseTime)\n\t            .tween(\"text\", textTween);\n\t    }\n\n\t    // Make the wave rise. wave and waveGroup are separate so that horizontal and vertical movement can be controlled independently.\n\t    var waveGroupXPosition = fillCircleMargin+fillCircleRadius*2-waveClipWidth;\n\t    if(config.waveRise){\n\t        waveGroup.attr('transform','translate('+waveGroupXPosition+','+waveRiseScale(0)+')')\n\t            .transition()\n\t            .duration(config.waveRiseTime)\n\t            .attr('transform','translate('+waveGroupXPosition+','+waveRiseScale(fillPercent)+')')\n\t            .each(\"start\", function(){ wave.attr('transform','translate(1,0)'); }); // This transform is necessary to get the clip wave positioned correctly when waveRise=true and waveAnimate=false. The wave will not position correctly without this, but it's not clear why this is actually necessary.\n\t    } else {\n\t        waveGroup.attr('transform','translate('+waveGroupXPosition+','+waveRiseScale(fillPercent)+')');\n\t    }\n\n\t    if(config.waveAnimate) animateWave();\n\n\t    function animateWave() {\n\t        wave.attr('transform','translate('+waveAnimateScale(wave.attr('T'))+',0)');\n\t        wave.transition()\n\t            .duration(config.waveAnimateTime * (1-wave.attr('T')))\n\t            .ease('linear')\n\t            .attr('transform','translate('+waveAnimateScale(1)+',0)')\n\t            .attr('T', 1)\n\t            .each('end', function(){\n\t                wave.attr('T', 0);\n\t                animateWave(config.waveAnimateTime);\n\t            });\n\t    }\n\n\t    function GaugeUpdater(){\n\t        this.update = function(value){\n\t            var newFinalValue = parseFloat(value).toFixed(2);\n\t            var textRounderUpdater = function(value){ return Math.round(value); };\n\t            if(parseFloat(newFinalValue) != parseFloat(textRounderUpdater(newFinalValue))){\n\t                textRounderUpdater = function(value){ return parseFloat(value).toFixed(1); };\n\t            }\n\t            if(parseFloat(newFinalValue) != parseFloat(textRounderUpdater(newFinalValue))){\n\t                textRounderUpdater = function(value){ return parseFloat(value).toFixed(2); };\n\t            }\n\n\t            var textTween = function(){\n\t                var i = d3.interpolate(this.textContent, parseFloat(value).toFixed(2));\n\t                return function(t) { this.textContent = textRounderUpdater(i(t)) + percentText; }\n\t            };\n\n\t            text1.transition()\n\t                .duration(config.waveRiseTime)\n\t                .tween(\"text\", textTween);\n\t            text2.transition()\n\t                .duration(config.waveRiseTime)\n\t                .tween(\"text\", textTween);\n\n\t            var fillPercent = Math.max(config.minValue, Math.min(config.maxValue, value))/config.maxValue;\n\t            var waveHeight = fillCircleRadius*waveHeightScale(fillPercent*100);\n\t            var waveRiseScale = d3.scale.linear()\n\t                // The clipping area size is the height of the fill circle + the wave height, so we position the clip wave\n\t                // such that the it will overlap the fill circle at all when at 0%, and will totally cover the fill\n\t                // circle at 100%.\n\t                .range([(fillCircleMargin+fillCircleRadius*2+waveHeight),(fillCircleMargin-waveHeight)])\n\t                .domain([0,1]);\n\t            var newHeight = waveRiseScale(fillPercent);\n\t            var waveScaleX = d3.scale.linear().range([0,waveClipWidth]).domain([0,1]);\n\t            var waveScaleY = d3.scale.linear().range([0,waveHeight]).domain([0,1]);\n\t            var newClipArea;\n\t            if(config.waveHeightScaling){\n\t                newClipArea = d3.svg.area()\n\t                    .x(function(d) { return waveScaleX(d.x); } )\n\t                    .y0(function(d) { return waveScaleY(Math.sin(Math.PI*2*config.waveOffset*-1 + Math.PI*2*(1-config.waveCount) + d.y*2*Math.PI));} )\n\t                    .y1(function(d) { return (fillCircleRadius*2 + waveHeight); } );\n\t            } else {\n\t                newClipArea = clipArea;\n\t            }\n\n\t            var newWavePosition = config.waveAnimate?waveAnimateScale(1):0;\n\t            wave.transition()\n\t                .duration(0)\n\t                .transition()\n\t                .duration(config.waveAnimate?(config.waveAnimateTime * (1-wave.attr('T'))):(config.waveRiseTime))\n\t                .ease('linear')\n\t                .attr('d', newClipArea)\n\t                .attr('transform','translate('+newWavePosition+',0)')\n\t                .attr('T','1')\n\t                .each(\"end\", function(){\n\t                    if(config.waveAnimate){\n\t                        wave.attr('transform','translate('+waveAnimateScale(0)+',0)');\n\t                        animateWave(config.waveAnimateTime);\n\t                    }\n\t                });\n\t            waveGroup.transition()\n\t                .duration(config.waveRiseTime)\n\t                .attr('transform','translate('+waveGroupXPosition+','+newHeight+')')\n\t        }\n\t    }\n\n\t    return new GaugeUpdater();\n\t}\n\n\trender () {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t<svg id=\"fillgauge1\" width=\"97%\" height=\"250\"></svg>\n\t\t\t\t<svg id=\"fillgauge2\" width=\"19%\" height=\"200\"></svg>\n\t\t\t\t<svg id=\"fillgauge3\" width=\"19%\" height=\"200\" ></svg>\n\t\t\t\t<svg id=\"fillgauge4\" width=\"19%\" height=\"200\"></svg>\n\t\t\t\t<svg id=\"fillgauge5\" width=\"19%\" height=\"200\"></svg>\n\t\t\t\t<svg id=\"fillgauge6\" width=\"19%\" height=\"200\"></svg>\n\t\t\t</div>\n\t\t)\n\t}\n}\n\n","desc":" 这是描述"},{"example":<Demo6 />,"title":" 这是标题","code":"/**\n*\n* @title 这是标题\n* @description 这是描述\n*\n*/\n\nimport React, { Component } from 'react';\nimport D3Graph from 'tinper-bee';\n\n\nclass Demo6 extends Component {\n    componentDidMount () {\n        var margin = {top: 40, right: 40, bottom: 40, left: 40},\n        width = 960 - margin.left - margin.right,\n        height = 500 - margin.top - margin.bottom;\n\n    var x = d3.scale.linear()\n        .domain([0, 1])\n        .range([0, width]);\n\n    var y = d3.scale.linear()\n        .domain([0, 1])\n        .range([height, 0]);\n\n    var z = d3.scale.linear()\n        .domain([2 / 3, 1]) // D3 3.x tension is buggy!\n        .range([\"brown\", \"steelblue\"]);\n\n    var xAxis = d3.svg.axis()\n        .scale(x)\n        .orient(\"bottom\");\n\n    var yAxis = d3.svg.axis()\n        .scale(y)\n        .orient(\"left\");\n\n    var line = d3.svg.line()\n        .interpolate(\"cardinal\")\n        .x(function(d) { return x(d.x); })\n        .y(function(d) { return y(d.y); });\n\n    var svg = d3.select(\"#tsv\").append(\"svg\")\n        .attr(\"width\", width + margin.left + margin.right)\n        .attr(\"height\", height + margin.top + margin.bottom)\n      .append(\"g\")\n        .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n    d3.tsv(\"data.tsv\", type, function(error, data) {\n      if (error) throw error;\n\n      svg.append(\"g\")\n          .attr(\"class\", \"axis axis--x\")\n          .attr(\"transform\", \"translate(0,\" + height + \")\")\n          .call(xAxis);\n\n      svg.append(\"g\")\n          .attr(\"class\", \"axis axis--y\")\n          .call(yAxis);\n\n      svg.selectAll(\".line\")\n          .data(z.ticks(6))\n        .enter().append(\"path\")\n          .attr(\"class\", \"line\")\n          .attr(\"d\", function(d) { return line.tension(d)(data); })\n          .style(\"stroke\", z);\n\n      svg.selectAll(\".dot\")\n          .data(data)\n        .enter().append(\"circle\")\n          .attr(\"class\", \"dot\")\n          .attr(\"cx\", function(d) { return x(d.x); })\n          .attr(\"cy\", function(d) { return y(d.y); })\n          .attr(\"r\", 3.5);\n    });\n\n    function type(d) {\n      d.x = +d.x;\n      d.y = +d.y;\n      return d;\n    }\n    }\n    render () {\n        return (\n            <div id=\"tsv\"></div>\n        )\n    }\n}\n\n","desc":" 这是描述"},{"example":<Demo7 />,"title":" 这是标题","code":"\n\n\n/**\n*\n* @title 这是标题\n* @description 这是描述\n*\n*/\n\nimport React, { Component } from 'react';\nimport D3Graph from 'tinper-bee';\n\n\nclass Demo6 extends Component {\n    componentDidMount () {\n        var width = 960,\n            height = 500;\n\n        var nodes = [];\n\n        var svg = d3.select(\"#dot\").append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n\n        var force = d3.layout.force()\n            .charge(-20)\n            .size([width, height])\n            .nodes(nodes)\n            .on(\"tick\", tick)\n            .start();\n\n        function tick() {\n          svg.selectAll(\"circle\")\n              .attr(\"cx\", function(d) { return d.x; })\n              .attr(\"cy\", function(d) { return d.y; });\n        }\n\n        var interval = setInterval(function() {\n          var d = {\n            x: width / 2 + 2 * Math.random() - 1,\n            y: height / 2 + 2 * Math.random() - 1\n          };\n\n          svg.append(\"circle\")\n              .data([d])\n              .attr(\"r\", 1e-6)\n            .transition()\n              .ease(Math.sqrt)\n              .attr(\"r\", 4.5);\n\n          if (nodes.push(d) > 300) clearInterval(interval);\n          force.start();\n        }, 30);\n    }\n    render () {\n        return (\n            <div id=\"dot\"></div>\n        )\n    }\n}\n\n","desc":" 这是描述"},{"example":<Demo8 />,"title":" 这是标题","code":"/**\n*\n* @title 这是标题\n* @description 这是描述\n*\n*/\n\nimport React, { Component } from 'react';\nimport D3Graph from 'tinper-bee';\n\nclass Demo8 extends Component {\n\tcomponentDidMount () {\n\t\tvar duration = 2500,\n\t\t    delay = 500;\n\n\t\tvar width = 960,\n\t\t    height = 500;\n\n\t\tvar x = d3.time.scale()\n\t\t    .domain([new Date(2010, 0, 2), new Date(2010, 1, 1)])\n\t\t    .range([0, width]);\n\n\t\tvar xAxis = d3.svg.axis()\n\t\t    .scale(x)\n\t\t    .orient(\"bottom\")\n\t\t    .tickSize(6, 0)\n\t\t    .tickFormat(d3.time.format(\"%m/%d\"));\n\n\t\tvar svg = d3.select(\"#date\").append(\"svg\")\n\t\t    .attr(\"width\", width)\n\t\t    .attr(\"height\", height);\n\n\t\tvar g = svg.append(\"g\")\n\t\t    .attr(\"class\", \"axis\")\n\t\t    .attr(\"transform\", \"translate(0,\" + height / 2 + \")\")\n\t\t    .call(xAxis);\n\n\t\tsetInterval(update, duration + delay);\n\n\t\tfunction update() {\n\t\t  x.domain([new Date(2010, 0, 2), new Date(2010, 0, Math.floor(Math.random() * 21) + 10)]);\n\n\t\t  g.transition()\n\t\t      .duration(duration)\n\t\t      .call(xAxis);\n\t\t}\n\t}\n\trender () {\n\t\treturn (\n\t\t\t<div id=\"date\">\n\t\t\t\t\n\t\t\t</div>\n\t\t)\n\t}\n}\n\n","desc":" 这是描述"}]


class Demo extends Component {
    constructor(props){
        super(props);
        this.state = {
            open: false
        }
        this.handleClick = this.handleClick.bind(this);
    }
    handleClick() {
        this.setState({ open: !this.state.open })
    }

    render () {
        const { title, example, code, desc  } = this.props;
        let caret = this.state.open ? CARETUP : CARET;
        let text = this.state.open ? "隐藏代码" : "查看代码";

        const footer = (
            <Button shape="block" onClick={ this.handleClick }>
                { caret }
                { text }
            </Button>
        );
        return (
            <Col md={12} >
                <h3>{ title }</h3>
                <p>{ desc }</p>
                <Panel collapsible headerContent expanded={ this.state.open } colors='bordered' header={ example } footer={footer} footerStyle = {{padding: 0}}>
                    <pre><code className="hljs javascript">{ code }</code></pre>
                </Panel>
            </Col>
        )
    }
}

class DemoGroup extends Component {
    constructor(props){
        super(props)
    }
    render () {
        return (
                <Row>
                    {DemoArray.map((child,index) => {

                        return (
                            <Demo example= {child.example} title= {child.title} code= {child.code} desc= {child.desc} key= {index}/>
                        )

                    })}
                </Row>
        )
    }
}

ReactDOM.render(<DemoGroup/>, document.getElementById('tinperBeeDemo'));
